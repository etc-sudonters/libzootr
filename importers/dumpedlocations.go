package importers

import (
	"io"
	"iter"
	"sudonters/libzootr/internal/json"

	"github.com/etc-sudonters/substrate/slipup"
)

var DumpLocations = &DumpedLocations{}
var emptyLocation = DumpedLocation{}

type DumpedLocation struct {
	Categories          []string
	Name, Type, Default string
}

// imports location file generated by dump-zootr.py
type DumpedLocations struct{}

// yields locations from the reader until the reader is completely consumed or
// an error occurs. If an error occurs then an empty DumpedLocation is yielded
// and the error will not be nil. Iteration may be canceled from the provided
// context
//
//	func storeLocation(importer.DumpedLocation)
//
//	for location, err := importers.DumpLocations.ImportFrom(ctx, locationReader) {
//	    if err != nil {
//	        return err
//	    }
//	    storeLocation(location)
//	}
func (this *DumpedLocations) ImportFrom(ctx ctx, r io.Reader) iter.Seq2[DumpedLocation, error] {
	return func(yield func(DumpedLocation, error) bool) {
		parser := json.ParserFrom(r)
		locations, notLocationArray := parser.ReadArray()
		if notLocationArray != nil {
			yield(emptyLocation, notLocationArray)
			return
		}
		for locations.More() {
			select {
			case <-ctx.Done():
				yield(emptyLocation, ctx.Err())
				return
			default:
				obj, notLocationErr := locations.ReadObject()
				if notLocationErr != nil {
					yield(emptyLocation, notLocationErr)
					return
				}

				dumped, dumpErr := dumpOneLocation(ctx, obj)
				if !yield(dumped, dumpErr) || dumpErr != nil {
					return
				}
			}
		}
	}
}

func dumpOneLocation(ctx ctx, obj *json.ObjectParser) (DumpedLocation, error) {
	var location DumpedLocation
	var property string

	defer func() {
		if recovered := recover(); recovered != nil {
			var panicwith error
			switch recovered := recovered.(type) {
			case error:
				panicwith = slipup.Describef(recovered, "while handling location %#v last property %q", location, property)
			default:
				panicwith = slipup.Createf("while handling location: %#v last property %q: %v", location, property, recovered)
			}
			panic(panicwith)
		}
	}()

	for obj.More() {
		select {
		case <-ctx.Done():
			return location, ctx.Err()
		default:
			var propertyErr error
			property, propertyErr = obj.ReadPropertyName()
			if propertyErr != nil {
				return location, propertyErr
			}

			var readErr error
			switch property {
			case "categories":
				switch obj.Current().Kind {
				case json.NULL:
					location.Categories = []string{}
					obj.DiscardValue()
				case json.ARR_OPEN:
					readErr = json.ReadStringArrayInto(obj, &location.Categories)
				default:
					readErr = slipup.Createf("categories must be an array, found: %v", obj.Current())
				}
			case "name":
				location.Name, readErr = obj.ReadString()
			case "type":
				location.Type, readErr = obj.ReadString()
			case "vanilla":
				switch obj.Current().Kind {
				case json.NULL:
					location.Default = ""
					obj.DiscardValue()
				case json.STRING:
					location.Default, readErr = obj.ReadString()
				default:
					readErr = slipup.Createf("vanilla must be a string, found: %v", obj.Current())
				}
			default:
				readErr = slipup.Createf("unknown property %s", property)
			}

			if readErr != nil {
				return location, slipup.Describef(
					readErr, "failed while reading location %#v", location,
				)
			}
		}
	}

	return location, obj.ReadEnd()
}
