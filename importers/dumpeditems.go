package importers

import (
	"io"
	"iter"
	"log/slog"
	"sudonters/libzootr/internal/json"

	"github.com/etc-sudonters/substrate/slipup"
)

var DumpItems = &DumpedItems{}
var emptyItem = DumpedItem{}

type DumpedItem struct {
	Name, Type            string
	Advancement, Priority bool
	Special               map[string]any
}

// imports item file generated by dump-zootr.py
type DumpedItems struct{}

// yields items from the reader until the reader is completely consumed or an
// error occurs. If an error occurs then an empty DumpedItem is yielded and the
// error will not be nil. Iteration may be canceled from the provided context
//
//	func storeItem(DumpedItem)
//
//	for item, err := importers.DumpItems.ImportFrom(ctx, itemReader) {
//	    if err != nil {
//	        return err
//	    }
//	    storeItem(item)
//	}
func (this *DumpedItems) ImportFrom(ctx ctx, r io.Reader) iter.Seq2[DumpedItem, error] {
	return func(yield func(DumpedItem, error) bool) {
		parser := json.ParserFrom(r)
		items, notItemArray := parser.ReadArray()
		if notItemArray != nil {
			yield(emptyItem, notItemArray)
			return
		}
		for items.More() {
			select {
			case <-ctx.Done():
				yield(emptyItem, ctx.Err())
				return
			default:
				obj, notItemErr := items.ReadObject()
				if notItemErr != nil {
					yield(emptyItem, notItemErr)
					return
				}

				dumped, dumpErr := dumpOneItem(ctx, obj)
				if !yield(dumped, dumpErr) || dumpErr != nil {
					return
				}
			}
		}
	}
}

func dumpOneItem(ctx ctx, obj *json.ObjectParser) (DumpedItem, error) {
	var item DumpedItem
	var property string

	defer func() {
		if recovered := recover(); recovered != nil {
			var panicwith error
			switch recovered := recovered.(type) {
			case error:
				panicwith = slipup.Describef(recovered, "while handling item %#v last property %q", item, property)
			default:
				panicwith = slipup.Createf("while handling item: %#v last property %q: %v", item, property, recovered)
			}
			panic(panicwith)
		}
	}()

	for obj.More() {
		select {
		case <-ctx.Done():
			return item, ctx.Err()
		default:
			var propertyErr error
			property, propertyErr = obj.ReadPropertyName()
			if propertyErr != nil {
				return item, propertyErr
			}

			var readErr error
			switch property {
			case "name":
				item.Name, readErr = obj.ReadString()
				if item.Name == "Small Key (Ganons Castle)" {
					break
				}
			case "type":
				item.Type, readErr = obj.ReadString()
			case "advancement":
				item.Advancement, readErr = obj.ReadBool()
			case "priority":
				item.Priority, readErr = obj.ReadBool()
			case "special":
				slog.WarnContext(ctx, "unimplemented special import", "name", item.Name)
				readErr = obj.DiscardValue()
			default:
				readErr = slipup.Createf("unknown property %s", property)
			}

			if readErr != nil {
				return item, slipup.Describef(
					readErr, "failed while reading item %#v", item,
				)
			}
		}
	}

	return item, obj.ReadEnd()
}
